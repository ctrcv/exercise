

## Leetcode Hot 100题

#### 1. 两数之和*

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:

> 给定 nums = [2, 7, 11, 15], target = 9
>
> 因为 nums[0] + nums[1] = 2 + 7 = 9
>所以返回 [0, 1]

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        # res = []
        for i, n in enumerate(nums):
            dic[n] = i

        # for i, n in enumerate(nums):
        #     dif = target - n
        #     if dif in dic and dic[dif] != i:
        #         res.append(i)
        #         res.append(dic[dif])
        #         break
        # return res
        for i, n in enumerate(nums):
            dif = target - n
            if dif in dic and dic[dif] != i:
                return [i, dic[dif]]
```



#### 2. 两数相加**

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

> 示例：
>
> 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
> 输出：7 -> 0 -> 8
> 原因：342 + 465 = 807

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next


class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = p = ListNode()
        flag = 0
        while l1 or l2 or flag:
            s = (l1.val if l1 else 0) + (l2.val if l2 else 0) + flag
            p.next = ListNode(s % 10)
            p = p.next
            flag = s // 10
            
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None

        return head.next
```



#### 3. 无重复字符的最长子串**

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

> 示例 1:
>
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> 示例 2:
>
> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> 示例 3:
>
> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> 示例 4:
>
> 输入: s = ""
> 输出: 0

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        n = len(s)
        if n < 2: return n

        # 滑动窗口思想
        # 方法1： 标记字符的位置
        # dic = {}
        # left, right = 0, 0
        # maxlen = 0
        # while right < n:
        #     c = s[right]
        #
        #     if c in dic:
        #         left = max(dic[c], left)
        #     maxlen = max(maxlen, right - left + 1)
        #     dic[c] = right + 1
        #     right += 1
        #
        # return maxlen

        # 方法2：统计窗口内的字符数
        # 可用set替换dict
        left, right = 0, 0
        maxlen = 0
        dic = {}
        while right < n:
            if s[right] not in dic:
                dic[s[right]] = 1
                right += 1
                maxlen = max(maxlen, len(dic))
            else:
                del dic[s[left]]
                left += 1

        return maxlen
```

#### 4. [寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)***@

给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。

进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？

> 示例 1：
>
> 输入：nums1 = [1,3], nums2 = [2]
> 输出：2.00000
> 解释：合并数组 = [1,2,3] ，中位数 2
> 示例 2：
>
> 输入：nums1 = [1,2], nums2 = [3,4]
> 输出：2.50000
> 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
> 示例 3：
>
> 输入：nums1 = [0,0], nums2 = [0,0]
> 输出：0.00000
> 示例 4：
>
> 输入：nums1 = [], nums2 = [1]
> 输出：1.00000
> 示例 5：
>
> 输入：nums1 = [2], nums2 = []
> 输出：2.00000
>
>
> 提示：
>
> nums1.length == m
> nums2.length == n
> 0 <= m <= 1000
> 0 <= n <= 1000
> 1 <= m + n <= 2000
> -106 <= nums1[i], nums2[i] <= 106

[参考解析](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/)

```python

```

#### 5. [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)**

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

> **示例 1：**
>
> ```
> 输入: "babad"
> 输出: "bab"
> 注意: "aba" 也是一个有效答案。
> ```
>
> **示例 2：**
>
> ```
> 输入: "cbbd"
> 输出: "bb"
> ```

[参考解析](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/)

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        # 1. 暴力匹配:O(N^3), O(1)
        # n = len(s)
        # if n < 2:
        #     return s
        #
        # maxlen = 1
        # res = s[0]
        # for i in range(n - 1):
        #     for j in range(i + 1, n):
        #         if self.isPalindrome(s, i, j) and j - i + 1 > maxlen:
        #             maxlen = j - i + 1
        #             res = s[i: j + 1]
        #
        # return res

        # def isPalindrome(self, s, left, right):
        #     while left < right:
        #         if s[left] != s[right]:
        #             return False
        #         left += 1
        #         right -= 1
        #
        #     return True

        # 2.动态规划：O(N^2), O(N^2)
        # n = len(s)
        # if n < 2:
        #     return s
        # # dp[i][j]状态表示从索引i到j的子串是否为回文
        # dp = [[False] * n for _ in range(n)]
        # start, maxlen = 0, 1
        # for i in range(n):
        #     dp[i][i] = True
        #
        # 注意填表顺序
        # for j in range(1, n):
        #     for i in range(0, n):
        #         if s[i] == s[j]:
        #             if j - 1 - (i + 1) + 1 < 2:
        #                 dp[i][j] = True
        #             else:
        #                 dp[i][j] = dp[i + 1][j - 1]
        #         else:
        #             dp[i][j] = False
        #
        #         if dp[i][j]:
        #             cur_len = j - i + 1
        #             if cur_len > maxlen:
        #                 maxlen = cur_len
        #                 start = i
        #         return s[start:start + maxlen]

        # 3. 中心扩撒法
        size = len(s)
        if size < 2:
            return s

        # 至少是 1
        max_len = 1
        res = s[0]

        for i in range(size):
            palindrome_odd, odd_len = self.__center_spread(s, size, i, i)
            palindrome_even, even_len = self.__center_spread(s, size, i, i + 1)

            # 当前找到的最长回文子串
            cur_max_sub = palindrome_odd if odd_len >= even_len else palindrome_even
            if len(cur_max_sub) > max_len:
                max_len = len(cur_max_sub)
                res = cur_max_sub

        return res

    def __center_spread(self, s, size, left, right):
        """
        left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数
        right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数
        """
        i = left
        j = right

        while i >= 0 and j < size and s[i] == s[j]:
            i -= 1
            j += 1
        return s[i + 1:j], j - i - 1
```

#### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)***@

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

示例 1：

```
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

示例 2:

```
输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

示例 3：

```
输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```


示例 4：

```
输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```

示例 5：

```
输入：s = "mississippi" p = "mis*is*p*."
输出：false
```

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)**

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器。

示例1：

![示例1图](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```


示例 2：

```
输入：height = [1,1]
输出：1
```

示例 3：

```
输入：height = [4,3,2,1,4]
输出：16
```

示例 4：

```
输入：height = [1,2,1]
输出：2
```


提示：

```
n = height.length
2 <= n <= 3 * 104
0 <= height[i] <= 3 * 104
```

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # 1. 暴力法：超时
        # n = len(height)
        # res = 0
        # for i in range(n):
        #     for j in range(i + 1, n):
        #         t = (j - i) * min(height[i], height[j])
        #         res = max(res, t)
        #
        # return res

        # 2.双指针
        i, j = 0, len(height) - 1
        res = 0
        while i < j:
            t = (j - i) * min(height[i], height[j])
            res = max(res, t)
            if height[i] <= height[j]:
                i += 1
            else:
                j -= 1
        return res
```

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)**

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例：

```
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

```python
from typing import List


class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        # 1. 暴力算法，时间复杂度O(n^3)
        # 2. 双指针法，O(n^2)
        n = len(nums)
        if n < 3:
            return []
        # 先对nums排序
        nums.sort()
        res = []
        # 设置三指针遍历求和
        # 第一个指针
        for i in range(n):
            # 因为nums是排序后的序列，如果nums[i] > 0，则表示后面的任意序列和都不可能等于0
            # 直接返回
            if nums[i] > 0:
                return res
            # 对于重复的元素，直接跳过，避免出现重复解
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            # 剩余的两个指针
            left, right = i + 1, n - 1
            while left < right:
                t = nums[i] + nums[left] + nums[right]
                if t == 0:
                    res.append([nums[i], nums[left], nums[right]])
                    # 去除重复解
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                # 当t < 0,表示left指针所对应的元素值太小，需要往右移动
                elif t < 0:
                    left += 1
                # 不然，right指针左移
                else:
                    right -= 1

        return res
```

#### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)**

给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```

**说明：**

给定的 *n* 保证是有效的。

**进阶：**

你能尝试使用一趟扫描实现吗？

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

# 方法1：直接遍历删除，时间O(L), 空间O(1), 需要两次遍历
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        def getLength(head: ListNode) -> int:
            length = 0
            while head:
                length += 1
                head = head.next
            return length
        
        dummy = ListNode(0, head)
        # 先计算链表长度
        length = getLength(head)
        cur = dummy
        for i in range(1, length - n + 1):
            cur = cur.next
        # 删除倒数第n个节点
        cur.next = cur.next.next
        return dummy.next

# 方法2：使用栈删除
# 方法3：双指针一次遍历，时间O(L),O(1)
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        p1 = head
        dummy = ListNode(0, head)
        p2 = dummy
        # 第一个指针先走n步
        for i in range(n):
            p1 = p1.next
        # 两指针同时移动
        while p1.next:
            p1 = p1.next
            p2 = p2.next
		# 节点删除
        p2.next = p2.next.next
        return dummy.next

```

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)*


给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**

```
输入: "()"
输出: true
```

**示例 2:**

```
输入: "()[]{}"
输出: true
```

**示例 3:**

```
输入: "(]"
输出: false
```

**示例 4:**

```
输入: "([)]"
输出: false
```

**示例 5:**

```
输入: "{[]}"
输出: true
```

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s:
            # 左括号，压入栈
            if c == '(' or c == "[" or c == "{":
                stack.append(c)
            # 右括号，判断括号是否对应
            elif not stack or self._getRightParent(c) != stack.pop():
                return False
		# 当输入的字符串中或剩余的字符串中只包含单括号时，栈中的元素还会有剩余
        # 所以最后还需要判断栈中元素是否为空
        return not stack
        #     elif c == ")" and (not stack or stack.pop() != "(") :
        #         return False
        #     elif c == "]" and (not stack or stack.pop() != "["):
        #         return False
        #     elif c == "}" and (not stack or stack.pop() != "{"):
        #         return False
        #
        # return True if not stack else False

    def _getRightParent(self, ch):
        if ch == ")": return "("
        if ch == "]": return "["
        if ch == "}": return "{"

        
# S = "([)]"这种情况是属于括号不匹配的情况，return False
# S = "()[]{()}"
S = "]"
print(Solution().isValid(S))

```

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)*

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
# 方法1。迭代法。时间复杂度为O(L1+L2),空间复杂度O(1)
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1: return l2
        if not l2: return l1

        pHead = ListNode()
        p = pHead
        while l1 and l2:
            if l1.val <= l2.val:
                p.next = l1
                l1 = l1.next
            else:
                p.next = l2
                l2 = l2.next
            p = p.next
        # 将l1或l2链表中剩余的元素加入链表
        p.next = l1 if l1 else l2

        return pHead.next
    
# ---------------------------------------------
# 方法2.递归。时间复杂度O(L1+L2),空间复杂度O(L1+L2)
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1: return l2
        if not l2: return l1

        if l1.val <= l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

```python
# 验证
L1, L2 = 3, 3
p1, p2 = ListNode(), ListNode()
pt1, pt2 = p1, p2
print("第一个链表")
for i in range(L1):
    x = int(input())
    pt1.next = ListNode(x)
    pt1 = pt1.next

print("第二个链表")
for i in range(L2):
    x = int(input())
    pt2.next = ListNode(x)
    pt2 = pt2.next

print("输出结果")
res = Solution().mergeTwoLists(p1.next, p2.next)
while res:
    print(res.val)
    res = res.next
```

#### [23.合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)***@

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

#### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)**

实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        if n <= 1:
            return
        # 从后向前遍历
        # 定义三个指针i，j，k
        i, j, k = n - 2, n - 1, n - 1
        # 1.找到第一个相邻升序的元素（i，j），满足A[i] < A[j]；此时从j到结尾的序列必定为降序的序列
        while i >= 0 and nums[i] >= nums[j]:
            i -= 1
            j -= 1
        # 判断是否为最后一个排列
        if i >= 0:
            # 2.从j到结尾的序列中查找第一个比A[i]大的元素A[k]
            while nums[i] > nums[k]:
                k -= 1
            # 3.交换A[i]和A[k]的值，交换后的从j到结尾的序列此时也必定为降序排列
            nums[i], nums[k] = nums[k], nums[i]
        # 4.对j到结尾序列进行逆置，使其升序排序
        i, j = j, n - 1
        while i < j:
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
            j -= 1
        # 5.如果在步骤1中找不到符合的相邻元素，则说明原始序列为降序序列，则直接跳到步骤4
```

[参考解析](https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/)

#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)***@

给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。

**示例 1:**

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

**示例 2:**

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```



#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)**

给你一个整数数组 nums ，和一个整数 target 。

该整数数组原本是按升序排列，但输入时在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。

请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

提示：

- 1 <= nums.length <= 5000
- -10^4 <= nums[i] <= 10^4
- nums 中的每个值都 独一无二
- nums 肯定会在某个点上旋转
- -10^4 <= target <= 10^4

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if not nums: return -1
        # 1.二分法查找
        n = len(nums)
        left, right = 0, n - 1
        while left <= right:
            mid = (left + right) // 2
            # 找到目标值，返回对应的索引
            if target == nums[mid]:
                return mid
            if nums[0] <= nums[mid]:
                # 如果处于区间[0, mid]区间内，则右指针移至中间指针的位置
                # 否则，左指针移动
                if nums[0] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[n - 1]:
                    left = mid + 1
                else:
                    right = mid - 1

        return -1
```



#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)**

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

**进阶：**

- 你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

```python
# 二分法 & 递归
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums:
            return [-1, -1]

        return self.search(nums, 0, len(nums) - 1, target)

    def search(self, nums, left, right, target):
        if left > right:
            return -1, -1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                if nums[left] != target:
                    left = self.search(nums, left + 1, mid, target)[0]
                if nums[right] != target:
                    right = self.search(nums, mid, right - 1, target)[1]
                return [left, right]

        return [-1, -1]
```



#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)**

​	给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

**说明：**

- 所有数字（包括 `target`）都是正整数。
- 解集不能包含重复的组合。

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```

**示例 2：**

```
输入：candidates = [2,3,5], target = 8,
所求解集为：
[
    [2,2,2,2],
      [2,3,3],
      [3,5]
]
```

```python
from typing import List


class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        # 1.回溯法
        # ans = []
        # n = len(candidates)
        #
        # def backtrack(i, val, record):
        #     # 如果差小于0，说明当前元素candidates[i]的值大了
        #     if val < 0:
        #         return
        #     # 等于0，说明方案可行
        #     if val == 0:
        #         ans.append(record[:])
        #         return
        #     for j in range(i, n):
        #         record.append(candidates[j])  # 添加
        #         backtrack(j, val - candidates[j], record)
        #         record.pop()  # 回溯
        #
        # backtrack(0, target, [])
        # return ans

        # 2. 回溯法，剪枝
        # 对candidates进行排序，当差值val<0时，则表示当前位置i之后的元素都不会满足要求
        # 因此跳过进一步的回溯
        # ans = []
        # n = len(candidates)
        # # 排序
        # candidates.sort()
        #
        # def backtrack(i, val, record):
        #     # 如果差小于0，说明当前元素candidates[i]的值大了
        #     if val < 0:
        #         return
        #     # 等于0，说明方案可行
        #     if val == 0:
        #         ans.append(record[:])
        #         return
        #     for j in range(i, n):
        #         if val - candidates[j] < 0:
        #             break
        #         record.append(candidates[j])  # 添加
        #         backtrack(j, val - candidates[j], record)
        #         record.pop()  # 回溯
        #
        # backtrack(0, target, [])
        # return ans

        # 方法1另一种写法,官方提供的不剪枝的朴素回溯法
        # 时间复杂度：O（S），S是所有可行解组成的长度之和，空间复杂度O（target）
        ans = []
        n = len(candidates)

        def backtrack(i, val, record):
            if i == n:
                return
            if val == 0:
                ans.append(record[:])
                return

            # 选择当前数
            if val - candidates[i] >= 0:
                record.append(candidates[i])
                backtrack(i, val - candidates[i], record)
                record.pop()

            # 直接跳过，通过索引后移实现for功能
            backtrack(i + 1, val, record)
        backtrack(0, target, [])
        return ans


# Candidates = [2,3,6,7]
# Target = 7
Candidates = [2, 3, 5]
Target = 8
print(Solution().combinationSum(Candidates, Target))

```



#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)***@

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![42示例图](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```



#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)**

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

**示例:**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

```python
from typing import List


class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        # 方法1：添加一个标记数组
        # 标记数组的方法还可以具有有序性的特点
        # res = []
        # n = len(nums)
        # used = [False] * n
        #
        # def backtrack(record):
        #     if len(record) == n:
        #         res.append(record[:])
        #         return
        #     for i in range(n):
        #         if not used[i]:
        #             used[i] = True
        #             record.append(nums[i])
        #             backtrack(record)
        #             used[i] = False
        #             record.pop()
        #
        # backtrack([])
        # return res

        # 方法2： 将数组分成两个部分，前半部分是已排列过的数据，后半部分为没有排列过的
        # 如：nums = [1, 2, 3,,4],分为两部分： [1, 2 | 3, 4], 1和2为已经使用过的数据
        res = []
        n = len(nums)

        def backtrack(first):
            if first == n:
                res.append(nums[:])
                return
            for i in range(first, n):
                # 注意：i的初始位置需要从first开始，而不是first + 1
                # 动态维护数组
                # 交换双方位置
                nums[first], nums[i] = nums[i], nums[first]
                backtrack(first + 1)
                nums[first], nums[i] = nums[i], nums[first]

        backtrack(0)
        return res


Nums = [1, 2, 3]
print(Solution().permute(Nums))

```

#### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)**

给定一个 *n* × *n* 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

**说明：**

你必须在**[原地](https://baike.baidu.com/item/原地算法)**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。

**示例 1:**

```python
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**示例 2:**

```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        if not matrix:
            return
        n = len(matrix)
        # 方法1：先转置矩阵，再每行翻转
        # 时间复杂度O(N^2)
        for i in range(n):
            for j in range(i, n):
                matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i]

        for i in range(n):
            for j in range(n//2):
                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]
```



#### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)**

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

**示例:**

```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

**说明：**

- 所有输入均为小写字母。
- 不考虑答案输出的顺序。

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        if not strs:
            return []

        # 方法1. 字符串排序,时间复杂度O(nklog(k))，k是字符串的最大长度， 空间复杂度O（nk）
        # dic = {}
        # for s in strs:
        #     key = "".join(sorted(s))
        #     if key not in dic:
        #         dic[key] = [s]
        #     else:
        #         dic[key].append(s)
        # return list(dic.values())

        # 方法2：计数,时间复杂度O（n（k+26）），生成哈希表的键需要O（26）的时间复杂度
        dic = {}
        for s in strs:
            # 两个字符串中的相同字母出现的次数一定是相同的
            # 故可以将每个字母出现的次数使用字符串表示
            count = [0] * 26
            for c in s:
                count[ord(c) - ord("a")] += 1

            # 数组需要转换成tuple才能哈希
            key = tuple(count)
            if key not in dic:
                dic[key] = [s]
            else:
                dic[key].append(s)

        return list(dic.values())
```



#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)*

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶:**

如果你已经实现复杂度为 O(*n*) 的解法，尝试使用更为精妙的分治法求解。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 1.贪心算法，时间复杂度O(n),空间O(1)
        # 主要思想：判断当前位置之前的序列元素和是否大于0.
        # 如果大于0，则与当前元素相加，记作当前和curr_sum；如果小于0，则curr_sum直接取当前元素值
        # 对比curr_sum与最大和max_sum，取最大值赋与max_sum
        # curr_sum = max_sum = nums[0]
        # for i, num in enumerate(nums):
        #     if i == 0:
        #         continue
        #     curr_sum = max(curr_sum + num, num)
        #     max_sum = max(max_sum, curr_sum)
        #
        # return max_sum

        # 方法2：动态规划,复杂度同
        # 主要思想：判断原地修改后的nums中当前位置的前一个位置的值是否大于0
        # 如果前一个位置值大于0，则当前位置的新值等于两者之和；否则，当前值保持不变.最后，取数组中的最大值返回
        max_sum = nums[0]
        for i in range(1, len(nums)):
            if nums[i - 1] > 0:
                nums[i] += nums[i - 1]
            max_sum = max(max_sum, nums[i])

        return max_sum
```



#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)**

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

**示例 1:**

```
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```

**示例 2:**

```
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        # 贪心思想，尽可能到达最远的位置
        # 主要思想：如果能到达某个位置，那一定能到达它前面的所有位置
        # 方法：初始化最远位置为 0，然后遍历数组，如果当前位置能到达，并且当前位置+跳数>最远位置，就更新最远位置。最后比较最远位置和数组长度。
        # 初始化当前能够到达的最远位置
        # max_i = 0
        # for i in range(len(nums)):
        #     # 如果当前位置可达，且当前位置加上当前位置能够跳跃的最大跳数大于最远跳数
        #     # 则更新最远跳数max_i
        #     if max_i >= i:
        #         max_i = max(max_i, i + nums[i])
        #
        # # 如果最远跳数大于数组长度，则表示能够到达最后的位置
        # return max_i >= len(nums)
        
        # 小简化，提升速度
        max_i = 0
        for i in range(len(nums)):
            # 如果位置i大于能够到达的最远跳数，则说明当前位置之前的最大跳数不能够达到当前位置，说明后面位置也永远到达不了，直接返回
            if i > max_i: return False
            max_i = max(max_i, i + nums[i])
        return True
```



#### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)**

给出一个区间的集合，请合并所有重叠的区间。

**示例 1:**

```python
输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2:**

```
输入: intervals = [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        # 方法：排序 & 合并。时间和空间复杂度取决于排序的复杂度，即O(NlogN)，空间O(logN)，
        # 对每个区间的左端点进行排序
        intervals.sort(key=lambda x: x[0])

        merged = []
        for int in intervals:
            # 如果列表为空，或当前区间与上一个区间不重合，则直接添加
            if not merged or merged[-1][1] < int[0]:
                merged.append(int)
            else:
                # 否则，可以对区间进行合并
                merged[-1][1] = max(merged[-1][1], int[1])
        return merged
```



#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)**

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![不同路径](./62.不同路径.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 方法1：深度搜索DFS，运行超时
        # visited = [[False] * n for _ in range(m)]
        # global res
        # res = 0
        #
        # def dfs(i, j):
        #     if i == m - 1 and j == n - 1:
        #         global res
        #         res += 1
        #         return
        #
        #     if i < m and j < n:
        #         if not visited[i][j]:
        #             visited[i][j] = True
        #             dfs(i + 1, j)
        #             dfs(i, j + 1)
        #             visited[i][j] = False
        #
        # dfs(0, 0)
        # return res

        # 方法2：动态规划，时间复杂度O(MN),空间O(MN)
        # 主要思想：能够到达当前位置的路径和等于能够到达上一行同列位置的路径数 + 同一行前一列的路径数之和
        # dp = [[0] * n for _ in range(m)]
        # for i in range(m):
        #     for j in range(n):
        #         # 由于只能向下向右移动，所以第一行和第一列的位置能到达的路径数为1
        #         if i == 0 or j == 0:
        #             dp[i][j] = 1
        #         else:
        #             dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        #
        # return dp[-1][-1]

        # 方法3：动态规划，空间优化，时间复杂度O（MN）， 空间复杂度O（2N）= O(N)
        # 优化依据：dp[i][j]每次只与dp[i-1][j] 和 dp[i][j-1]有关
        # pre: 前一行，curr：当前行
        # pre, curr = [1] * n, [1] * n
        # for i in range(1, m):
        #     for j in range(1, n):
        #         curr[j] = pre[j] + curr[j - 1]
        #     pre = curr
        # return curr[-1]

        # 方法4：动态优化，空间优化,O(N)
        # 优化依据：?
        curr = [1] * n
        for i in range(1,m):
            for j in range(1,n):
                curr[j] += curr[j - 1]
        return curr[-1]
```

#### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)**

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

![不同路径](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.png)

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

**示例 1：**

![不同路径2](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/63.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842.jpg)

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        # 1.自写
        # if obstacleGrid[0][0] == 1:
        #     return 0
        # m, n = len(obstacleGrid), len(obstacleGrid[0])
        # dp = [[0] * n for _ in range(m)]
        # for i in range(m):
        #     for j in range(n):
        #         if obstacleGrid[i][j] == 1:
        #             dp[i][j] = 0
        #         else:
        #             if i == 0 and j == 0:
        #                 dp[0][0] = 1
        #             elif i == 0 and j > 0:
        #                 dp[i][j] += dp[i][j - 1]
        #             elif j == 0 and i > 0:
        #                 dp[i][j] += dp[i - 1][j]
        #             else:
        #                 dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        #         # print(i, j, dp)
        # return dp[-1][-1]

        #题解 2. 滚动数组优化
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        f = [0] * n
        f[0] = 0 if obstacleGrid[0][0] == 1 else 1
        for i in range(m):
            for j in range(n):
                if obstacleGrid[i][j] == 1:
                    f[j] = 0
                elif j >= 1 and obstacleGrid[i][j - 1] == 0:
                    f[j] += f[j - 1]

        return f[-1]
```



#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)**

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例 1：**

![最小路径和](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**示例 2：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

提示：

- m == grid.length
- n == grid[i].length
- 1 <= m, n <= 200
- 0 <= grid[i][j] <= 100

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        # 方法1. 动态规划
        # 当前位置最小值只与同行前一列或同列前一行的元素的最小值相关
        m, n = len(grid), len(grid[0])
        dp = [[float('inf')] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    dp[i][j] = grid[i][j]
                else:
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]

        return int(dp[-1][-1])

        # 优化：如题62相同，空间复杂度可以优化，例如每次只存储上一行的 \textit{dp}dp 值，则可以将空间复杂度优化到 O(n)O(n)。
```



#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)*

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        # 方法：动态规划
        # if n < 3: return n
        # dp = [0] * (n + 1)
        # dp[0], dp[1] = 1, 1
        # for i in range(2, n + 1):
        #     dp[i] = dp[i - 1] + dp[i - 2]
        # return dp[-1]

        # 空间优化
        if n < 3: return n
        a, b = 1, 2
        for i in range(3, n + 1):
            c = a + b
            a, b = b, c
        return c
```

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)***@

给你两个单词 `word1` 和 `word2`，请你计算出将 `word1` 转换成 `word2` 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```python
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

**提示：**

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        # 参考LCS的思路
        m, n = len(word1), len(word2)
        # 状态dp[i][j]表示最少的操作数使得word1的前i个字符和word2的前j个字符
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1): dp[i][0] = i
        for j in range(n + 1): dp[0][j] = j

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 当元素相同时，不进行操作
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                # 否则，对比
                else:
                    dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j] + 1))

        return dp[m][n]
```

#### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**进阶：**

- 你可以不使用代码库中的排序函数来解决这道题吗？
- 你能想出一个仅使用常数空间的一趟扫描算法吗？

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

**示例 3：**

```
输入：nums = [0]
输出：[0]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

```python
# 方法1~方法3参考自官方题解
# 方法1：单指针
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        n = len(nums)
        ptr = 0
        for i in range(n):
            if nums[i] == 0:
                nums[i], nums[ptr] = nums[ptr], nums[i]
                ptr += 1
        for i in range(ptr, n):
            if nums[i] == 1:
                nums[i], nums[ptr] = nums[ptr], nums[i]
                ptr += 1
# 方法2：双指针
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        n = len(nums)
        p0 = p1 = 0
        for i in range(n):
            if nums[i] == 1:
                nums[i], nums[p1] = nums[p1], nums[i]
                p1 += 1
            elif nums[i] == 0:
                nums[i], nums[p0] = nums[p0], nums[i]
                if p0 < p1:
                    nums[i], nums[p1] = nums[p1], nums[i]
                p0 += 1
                p1 += 1

# 方法3：双指针
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        n = len(nums)
        p0, p2 = 0, n - 1
        i = 0
        while i <= p2:
            while i <= p2 and nums[i] == 2:
                nums[i], nums[p2] = nums[p2], nums[i]
                p2 -= 1
            if nums[i] == 0:
                nums[i], nums[p0] = nums[p0], nums[i]
                p0 += 1
            i += 1
            
# 方法4：partition思想
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """

        def swqp(nums, idx1, idx2):
            nums[idx1], nums[idx2] = nums[idx2], nums[idx1]

        # 方法1. 使用快速排序中的partition思想，即
        # all in [0, zero) = 0
        # all in [zero, i) = 1
        # all in [two, len - 1] = 2
        # 时间复杂度：O(N)
        if len(nums) < 2: return
        i, zero, two = 0, 0, len(nums)
        while i < two:
            if nums[i] == 0:
                # 当值等于0时，交换i和zero的对应元素的值，然后i和zero都向右移
                swqp(nums, i, zero)
                i += 1
                zero += 1
            elif nums[i] == 1:
                # 当值等于1时，i指针右移，其余指针保持
                i += 1
            else:
                # 当值等于2时，因为two初始设置为nums的长度，直接处理会越界，需要先左移
                two -= 1
                swqp(nums, i, two)
```

以上方法时间复杂度均为O(N)，空间O(1)

[方法1~方法3参考](https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode-solution/)

[方法4参考](https://leetcode-cn.com/problems/sort-colors/solution/kuai-su-pai-xu-partition-guo-cheng-she-ji-xun-huan/)

#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)***@

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

**注意：**如果 s 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
```

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)**

给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）。

**说明：**解集不能包含重复的子集。

**示例:**

```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        if not nums: return [nums]
        # 方法1：回溯
        # 时间复杂度O(n*2^n).一共2^n个状态，每个状态需要O(n)的时间构建子集
        # 空间复杂度O(n). 临时数组 tt 的空间代价是 O(n)O(n)，递归时栈空间的代价为 O(n)O(n)。
        res = []

        def dfs(curr, t):
            # 记录答案
            if curr == len(nums):
                res.append(t[:])
                return
            # 考虑选择当前位置
            t.append(nums[curr])
            dfs(curr + 1, t)
            t.pop()
            # 不考虑选择当前位置
            dfs(curr + 1, t)

        dfs(0, [])
        return res
```

#### [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)**

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例:**

```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
```

**提示：**

- `board` 和 `word` 中只包含大写和小写英文字母。
- `1 <= board.length <= 200`

- `1 <= board[i].length <= 200`
- `1 <= word.length <= 10^3`

```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        # 方法：回溯法。
        # 时间复杂度：宽松上界：O(MN*3^L)，L表示word的长度
        # 在每次调用函数dfs时，除了第一次可以进入4个分支以外，
        # 其余时间我们最多会进入3个分支（因为每个位置只能使用一次，所以走过来的分支没法走回去）。
        # 由于单词长为 L，故 dfs(i, j, 0) 的时间复杂度为 O(3^L),而我们要执行 O(MN)次检查
        # 空间复杂度：O(MN)。额外开辟了 used 数组，同时栈的最大深度为O(min(L, MN))
        m, n = len(board), len(board[0])
        used = [[False] * n for _ in range(m)]
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        def dfs(i, j, k):
            # 如果borad[i][j] 与word的第k个字符不相同，则表示匹配错误
            if board[i][j] != word[k]:
                return False
            # 如果字符匹配，且已经匹配到结尾的字符，则搜索成功
            if k == len(word) - 1:
                return True

            # 标记该点已经遍历过
            used[i][j] = True
            for di, dj in directions:
                # 对四个方向遍历
                newi, newj = i + di, j + dj
                if 0 <= newi < m and 0 <= newj < n:
                    if not used[newi][newj]:
                        # 因为当前已经匹配了word的地k个字符，所以下一个匹配的字符是第word的k+1位的字符
                        if dfs(newi, newj, k + 1):
                            return True
            # 回溯
            used[i][j] = False

        # ！！！注意：因为可以从board上的任意位置开始搜索，所以需要遍历每个位置
        for i in range(m):
            for j in range(n):
                if dfs(i, j, 0):
                    return True

        return False
```

#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)***@

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。

![示例1](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A21.png)

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。

![示例2](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A22.png)

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 `10` 个单位。

**示例:**

```
输入: [2,1,5,6,2,3]
输出: 10
```

#### [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)***

给定一个仅包含 `0` 和 `1` 、大小为 `rows x cols` 的二维二进制矩阵，找出只包含 `1` 的最大矩形，并返回其面积。

 **示例 1：**

![示例1](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/85.%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2.jpg)

```
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：6
解释：最大矩形如上图所示。
```

**示例 2：**

```
输入：matrix = []
输出：0
```

**示例 4：**

```
输入：matrix = [["1"]]
输出：1
```

**示例 5：**

```
输入：matrix = [["0","0"]]
输出：0
```

提示：

- rows == matrix.length
- cols == matrix[0].length
- 0 <= row, cols <= 200
- matrix[i][j] 为 '0' 或 '1'

#### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)**

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

**示例 1：**

![示例](./imgs/94.二叉树的中序遍历.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

```python
from typing import List


# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


# 递归法。时间 & 空间 O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n)的级别。
# class Solution:
#     def inorderTraversal(self, root: TreeNode) -> List[int]:
#         res = []
#
#         def helper(node):
#             if not node: return
#             helper(node.left)
#             res.append(node.val)
#             helper(node.right)
#
#         helper(root)
#         return res

# 迭代法：用栈模拟还原递归过程
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        res, stack = [], []
        while root or stack:
            # 遍历到左子树底部
            while root:
                stack.append(root)
                root = root.left
            # 取值
            root = stack.pop()
            res.append(root.val)
            # 遍历右子树
            root = root.right

        return res
```

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)**

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

```python
class Solution:
    def numTrees(self, n: int) -> int:
        # 动态规划方法
        # 思想：假设n个节点存在二叉搜索树的个数是G(n)，令f(i)表示以i为根节点的二叉搜索树的个数，则：
        # G(n) = f(1) + f(2) + ... + f(n)
        # 当i为根节点时，左子树节点个数为 i-1 个，右子树节点个数为 n-i，则
        # f(i) = G(i - 1) * G(n - i)
        # 综上，G(n) = G(0) * G(n-1) + G(1) * G(n - 2) + ... + G(n - 1) * G(0)
        dp = [0] * (n + 1)
        dp[0], dp[1] = 1, 1
        for i in range(2, n + 1):
            for j in range(1, i + 1):
                dp[i] += dp[j - 1] * dp[i - j]

        return dp[n]
```

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)**

给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含**小于**当前节点的数。
- 节点的右子树只包含**大于**当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1:**

```
输入:
    2
   / \
  1   3
输出: true
```

**示例 2:**

```
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

```python
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 本题关键在于要先设定一个虚拟的值为极小值的根节点，
# 有了初始的虚拟根节点后，无论是使用递归还是迭代，或者三种遍历方式中的哪一个，都相对容易解决
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        # 递归1:
        # def helper(node, lower=float("-inf"), upper=float("inf")):
        #     if not node: return True
        #     val = node.val
        #     if val <= lower or val >= upper: return False
        #     if not helper(node.left, lower, val): return False
        #     if not helper(node.right, val, upper): return False
        #     return True
        # return helper(root)
        #
        # # 中序遍历，迭代版
        stack, inorder = [], float("-inf")
        while stack or root:
            while root:
                stack.append(root)
                root = root.left
            root = stack.pop()
            # 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if root.val <= inorder:
                return False
            inorder = root.val
            root = root.right
        return True

    # 中序遍历，递归版
    # pre = float("-inf")
    #
    # def isValidBST(self, root: TreeNode) -> bool:
    #     if not root: return True
    #     # 访问左子树
    #     if not self.isValidBST(root.left):
    #         return False
    #     # 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历
    #     if root.val <= self.pre:
    #         return False
    #     self.pre = root.val
    #     # 访问右子树
    #     if not self.isValidBST(root.right):
    #         return False
    #     return True
```

#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)*

给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

**进阶：**

你可以运用递归和迭代两种方法解决这个问题吗？

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None


class Solution:
    # 递归，时间空间复杂度均为O(n)
    # def isSymmetric(self, root: TreeNode) -> bool:
    #     def helper(node1, node2):
    #         # 如果同时到达树底，返回True
    #         if not node1 and not node2:
    #             return True
    #         # 如果左右子树形状不同，返回False
    #         if not node1 or not node2:
    #             return False
    #         # 判断节点值是否相同，左子树左节点和右节点、右节点和左节点是否相同
    #         if node1.val != node2.val:
    #             return False
    #         return helper(node1.left, node2.right) and helper(node1.right, node2.left)
    #
    #     if not root:
    #         return True
    #     return helper(root.left, root.right)

    # 迭代
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root or (not root.left and not root.right):
            return True
        # 使用队列保存节点
        queue = [root.left, root.right]
        while queue:
            # 从队列中取出两个节点
            left = queue.pop(0)
            right = queue.pop(0)
            # 如果两个节点同时为空则继续循环，只有一个为空则跳出循环
            if not left and not right:
                continue
            if not left or not right:
                return False
            # 比较两个节点值是否相同
            if left.val != right.val:
                return False
            # 将左节点的左节点，右节点的右节点放入队列
            queue.append(left.left)
            queue.append(right.right)
            # 将左节点的右节点，右节点的左节点放入队列
            queue.append(left.right)
            queue.append(right.left)

        return True
```

#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)**

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

**示例：**
二叉树：`[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层序遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

```python
from typing import List
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        # 广度优先搜索BFS
        queue = [root]
        res = []
        while queue:
            # 因为是要每层分别记录，所以需要根据每一层的节点个数循环遍历
            size = len(queue)
            level = []
            for i in range(size):
                node = queue.pop(0)
                level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(level)

        return res
```

#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)*

给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        # 深度优先搜索DFS
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)**

根据一棵树的前序遍历与中序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        # 对任意一颗二叉树而言，前序遍历的形式总是：[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]
        # 中序遍历的形式总是：[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]

        # 递归实现
        def builder(preorder_left, preorder_right, inorder_left, inorder_right):
            if preorder_left > preorder_right:
                return

            # 前序遍历的第一个节点就是根节点
            preorder_root = preorder_left
            # 在中序遍历的结果中获得根节点的索引
            inorder_root = index[preorder[preorder_root]]

            # 建立根节点
            root = TreeNode(preorder[preorder_root])
            # 获取左节点的节点数目
            left_treesize = inorder_root - inorder_left
            # 递归构造左子树，并连接到根节点
            # 先序遍历中「从 左边界+1 开始的 left_treesize」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
            root.left = builder(preorder_left + 1, preorder_left + left_treesize,
                                inorder_left, inorder_root - 1)
            # 递归构造左子树，并连接到根节点
            # 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
            root.right = builder(preorder_left + left_treesize + 1, preorder_right,
                                 inorder_root + 1, inorder_right)

            return root

        n = len(preorder)
        index = {element: i for i, element in enumerate(inorder)}
        return builder(0, n - 1, 0, n - 1)

        # 迭代实现
        # if not preorder:
        #     return None
        #
        # root = TreeNode(preorder[0])
        # stack = [root]
        # inorderIndex = 0
        # for i in range(1, len(preorder)):
        #     preorderVal = preorder[i]
        #     node = stack[-1]
        #     if node.val != inorder[inorderIndex]:
        #         node.left = TreeNode(preorderVal)
        #         stack.append(node.left)
        #     else:
        #         while stack and stack[-1].val == inorder[inorderIndex]:
        #             node = stack.pop()
        #             inorderIndex += 1
        #         node.right = TreeNode(preorderVal)
        #         stack.append(node.right)
        #
        # return root


```
#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)**

给定一个二叉树，原地)将它展开为一个单链表。

例如，给定二叉树

```
    1
   / \
  2   5
 / \   \
3   4   6
```

将其展开为：

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    pre = None

    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        # 方法：后序遍历。 因为使用前序遍历会导致的话，会导致右孩子丢失
        # 而后续遍历不会，因为更新当前的右指针的时候，当前节点的右孩子已经访问过了
        # 依次遍历 6 5 4 3 2 1，然后每遍历一个节点就将当前节点的右指针更新为上一个节点pre

        # 递归版，可运行
        # if not root:
        #     return
        # self.flatten(root.right)
        # self.flatten(root.left)
        # root.right = self.pre
        # root.left = None
        # self.pre = root

        # 迭代版,，改版代码有问题
        # stack = []
        # pre, curr = None, root
        #
        # while curr or stack:
        #     while curr:
        #         stack.append(curr)
        #         curr = curr.right
        #
        #     curr = stack.pop()
        #     # 在不存在左节点或右节点已经访问过的情况下，访问根节点
        #     if not curr.left or curr == pre:
        #
        #         curr.right = pre
        #         curr.left = None
        #         pre = curr
        #         # curr = None
        #     else:
        #         # 左节点还没有访问过就先访问左节点
        #         curr = curr.left

        # 官方题解
        # 1. 前序遍历. 因为前序遍历对节点进行操作会破坏树的原结构
        # 所有需要额外的存储空间O(n)，但是是属于在链表原地进行操作的
        preorderList = list()

        def preorderTraversal(root: TreeNode):
            if root:
                preorderList.append(root)
                preorderTraversal(root.left)
                preorderTraversal(root.right)

        preorderTraversal(root)
        size = len(preorderList)
        for i in range(1, size):
            prev, curr = preorderList[i - 1], preorderList[i]
            prev.left = None
            prev.right = curr

        # 1. 前序遍历迭代版，
        preorderList = list()
        stack = list()
        node = root

        while node or stack:
            while node:
                preorderList.append(node)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right

        size = len(preorderList)
        for i in range(1, size):
            prev, curr = preorderList[i - 1], preorderList[i]
            prev.left = None
            prev.right = curr

        # 2。前序遍历和展开同步进行
        # 只能通过迭代的形式实现
        if not root:
            return

        stack = [root]
        prev = None

        while stack:
            curr = stack.pop()
            if prev:
                prev.left = None
                prev.right = curr
            left, right = curr.left, curr.right
            if right:
                stack.append(right)
            if left:
                stack.append(left)
            prev = curr

        # 3. 寻找前驱节点，空间复杂度O(1)
        curr = root
        while curr:
            if curr.left:
                predecessor = nxt = curr.left
                while predecessor.right:
                    predecessor = predecessor.right
                predecessor.right = curr.right
                curr.left = None
                curr.right = nxt
            curr = curr.right

```

[参考解析](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/er-cha-shu-zhan-kai-wei-lian-biao-by-leetcode-solu/)

#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)*

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。

注意：你不能在买入股票前卖出股票。

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0

        # 从后往前遍历，取最大利益
        n = len(prices)
        max_profit = 0
        max_val = prices[n - 1]
        for i in range(n - 2, -1, -1):
            if max_val < prices[i]:
                max_val = prices[i]
            else:
                max_profit = max(max_profit, max_val - prices[i])
                
        return max_profit
```

#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)***@

给定一个非空二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点

**示例 1：**

```
输入：[1,2,3]

       1
      / \
     2   3

输出：6
```

**示例 2：**

```
输入：[-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出：42
```



#### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)***

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

**进阶：**你可以设计并实现时间复杂度为 `O(n)` 的解决方案吗？

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

**提示：**

- `0 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`

```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        # 使用set进行去重和降低查询复杂度
        # 时间复杂度和空间复杂度：O(n)
        num_set = set(nums)
        max_len = 0
        for num in num_set:
            # 因为num-1在while循环中已经遍历过了，不需要重复遍历
            if num - 1 not in num_set:
                curr_num = num
                curr_len = 1
                # 如果有连续的数字，则一直遍历下去
                while curr_num + 1 in num_set:
                    curr_num += 1
                    curr_len += 1
                max_len = max(max_len, curr_len)
        return max_len
```



#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)*

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

```
输入: [2,2,1]
输出: 1
```

**示例 2:**

```
输入: [4,1,2,1,2]
输出: 4
```

```python
from typing import List
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # 题目中说明重复的数字的重复次数为2次

        # 使用O(n)的额外空间的话，实现O(n)复杂度可以有以下方法
        # 1. 使用集合遍历数组，集合中存在则删除该元素，最后剩余的元素即为只出现一次的数字
        # 2. 使用哈希表遍历统计元素出现的次数
        # 3. 使用集合存储数组中的数字，去除重复的数字，对集合的元素求和再乘以2得到s1；统计原始数组的所有元素和s2
        # 不重复的数字则等于s1 - s2

        # 时间复杂度O(nlogn)的方法可以使用排序

        # 不使用额外O(n)空间，只使用常数空间，则可以使用异或运算的方法
        # 原因是两个数字进行异或，如果两个数字相同，异或后的结果为0；a^a = 0
        # 0与任意数字异或的结果为该数字; a^0 = a
        # 异或满足交换律和结合律 a ^ b ^ = b ^ a ^ a = b ^ (a ^ a) = b ^ 0 = b
        a = 0
        for num in nums:
            a = a ^ num
        return a
```

#### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)**

给定一个**非空**字符串 *s* 和一个包含**非空**单词的列表 *wordDict*，判定 *s* 是否可以被空格拆分为一个或多个在字典中出现的单词。

**说明：**

- 拆分时可以重复使用字典中的单词。
- 你可以假设字典中没有重复的单词。

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        # 将list转换成set，降低查询复杂度
        wordSet = set(wordDict)

        # 1.递归实现，超时
        # def helper(substr):
        #     if substr in wordSet:
        #         return True
        #     n = len(substr)
        #     for j in range(1, n):
        #         if helper(substr[:j]) and helper(substr[j:]):
        #             return True
        #     return False
        #
        # return helper(s)

        # 2.动态规划，时间O(n^2)，空间O(n)
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True  # dp[0]表示空串且合法
        for i in range(n):
            for j in range(i + 1, n + 1):
                if dp[i] and s[i: j] in wordSet:
                    dp[j] = True
        return dp[-1]
```



#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)*

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。**注意：pos 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

**进阶：**

你能用 *O(1)*（即，常量）内存解决此问题吗？

**示例 1：**

<img src="./imgs/141.环形链表.png" alt="示例" style="zoom:67%;" />

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

<img src="./imgs/141.环形链表2.png" alt="示例" />

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例3**

![示例3](./imgs/141.环形链表3.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

**提示：**

- 链表中节点的数目范围是 `[0, 104]`
- `-105 <= Node.val <= 105`
- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def hasCycle(self, head: ListNode) -> bool:
        if not head:
            return False
        if not head.next:
            return False
        # 快慢指针
        p1, p2 = head, head
        while p2 and p2.next:
            p1 = p1.next
            p2 = p2.next.next
            if p1 == p2:
                return True
        return False
```

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)**

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

**说明：**不允许修改给定的链表。

**进阶：**

- 你是否可以使用 `O(1)` 空间解决此题？

**示例 1：**

<img src="./imgs/141.环形链表.png" alt="示例" style="zoom:67%;" />



```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例2**

<img src="./imgs/141.环形链表2.png" alt="示例" />

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![示例3](./imgs/141.环形链表3.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        fast, slow = head, head
        # 先判断是否有环，如果有环，快指针的速度是慢指针的2倍，迟早会相遇
        while True:
            # 如果只有一个节点，则直接返回
            if not (fast and fast.next): return
            fast, slow = fast.next.next, slow.next
            if fast == slow:
                break

        # 有环的话，快慢指针相遇的节点不一定是环的入口节点
        # 相遇的节点与环入口节点的距离与链表头节点到环入口的距离相等，假设为a
        # 所以需要慢指针继续走指针a步才能到环入口
        fast = head
        while fast != slow:
            fast, slow = fast.next, slow.next
        return fast
```

#### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)**@

运用你所掌握的数据结构，设计和实现一个 [LRU (最近最少使用) 缓存机制](https://baike.baidu.com/item/LRU) 。

实现 `LRUCache` 类：

- LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
- int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
- void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

**进阶**：你是否可以在 `O(1)` 时间复杂度内完成这两种操作

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

提示：

- 1 <= capacity <= 3000
- 0 <= key <= 3000
- 0 <= value <= 104
- 最多调用 3 * 104 次 get 和 put

#### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)**@

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**进阶：**

- 你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

**示例 1：**

![示例1](./imgs/148.排序链表1.jpg)

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

**示例2**

![示例2](./imgs/148.排序链表2.jpg)

```
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```

**示例3**

```
输入：head = []
输出：[]
```

**提示：**

- 链表中节点的数目在范围 `[0, 5 * 104]` 内
- `-105 <= Node.val <= 105`

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


# 1. 自顶向下归并排序。时间复杂度O(nlogn), 空间复杂度O(logn),因为递归需要栈空间
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        def sortFunc(head: ListNode, tail: ListNode) -> ListNode:
            if not head:
                return head
            if head.next == tail:
                head.next = None
                return head
            slow = fast = head
            while fast != tail:
                slow = slow.next
                fast = fast.next
                if fast != tail:
                    fast = fast.next
            mid = slow
            return merge(sortFunc(head, mid), sortFunc(mid, tail))

        def merge(head1: ListNode, head2: ListNode) -> ListNode:
            dummyHead = ListNode(0)
            temp, temp1, temp2 = dummyHead, head1, head2
            while temp1 and temp2:
                if temp1.val <= temp2.val:
                    temp.next = temp1
                    temp1 = temp1.next
                else:
                    temp.next = temp2
                    temp2 = temp2.next
                temp = temp.next
            if temp1:
                temp.next = temp1
            elif temp2:
                temp.next = temp2
            return dummyHead.next

        return sortFunc(head, None)

# 自底向上排序。时间复杂度，O（nlogn）,空间复杂度O(1)
# class Solution:
#     def sortList(self, head: ListNode) -> ListNode:
#         def merge(head1: ListNode, head2: ListNode) -> ListNode:
#             dummyHead = ListNode(0)
#             temp, temp1, temp2 = dummyHead, head1, head2
#             while temp1 and temp2:
#                 if temp1.val <= temp2.val:
#                     temp.next = temp1
#                     temp1 = temp1.next
#                 else:
#                     temp.next = temp2
#                     temp2 = temp2.next
#                 temp = temp.next
#             if temp1:
#                 temp.next = temp1
#             elif temp2:
#                 temp.next = temp2
#             return dummyHead.next
# 
#         if not head:
#             return head
# 
#         length = 0
#         node = head
#         while node:
#             length += 1
#             node = node.next
# 
#         dummyHead = ListNode(0, head)
#         subLength = 1
#         while subLength < length:
#             prev, curr = dummyHead, dummyHead.next
#             while curr:
#                 head1 = curr
#                 for i in range(1, subLength):
#                     if curr.next:
#                         curr = curr.next
#                     else:
#                         break
#                 head2 = curr.next
#                 curr.next = None
#                 curr = head2
#                 for i in range(1, subLength):
#                     if curr and curr.next:
#                         curr = curr.next
#                     else:
#                         break
# 
#                 succ = None
#                 if curr:
#                     succ = curr.next
#                     curr.next = None
# 
#                 merged = merge(head1, head2)
#                 prev.next = merged
#                 while prev.next:
#                     prev = prev.next
#                 curr = succ
#             subLength <<= 1
# 
#         return dummyHead.next
```

[参考题解](https://leetcode-cn.com/problems/sort-list/solution/pai-xu-lian-biao-by-leetcode-solution/)

#### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)**

给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

**示例 1:**

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums:
            return 0
        n = len(nums)
        # 动态规划
        # 用两个数组分别记录最大、最小子数组乘积值
        # 当num[i] > 0时，当前位置子数组乘积的最大值等于前面子数组乘积最大值乘num[i]，结果与num[i]对比取最大值
        # 当num[i] <= 0时，当前位置子数组乘积的最大值等于子数组乘积最小值乘以num[i]，结果与num[i]比较取最大值
        # maxn = [0] * n
        # minn = [0] * n
        # maxn[0] = minn[0] = nums[0]
        # for i in range(1, n):
        #     if nums[i] > 0:
        #         maxn[i] = max(maxn[i - 1] * nums[i], nums[i])
        #         minn[i] = min(minn[i - 1] * nums[i], nums[i])
        #     else:
        #         maxn[i] = max(minn[i - 1] * nums[i], nums[i])
        #         minn[i] = min(maxn[i - 1] * nums[i], nums[i])
        #
        # return max(maxn)

        # 空间优化
        # maxn[i] 和 minn[i]的取值只取决于 maxn[i-1] 和 minn[i - 1]，minn也相同， 没必要申请O(n)的数组空间
        ans = maxn = minn = nums[0]
        for i in range(1, n):
            # 需要两个临时变量存储上一对值，防止max或min中的最大最小值不是上一对的数值
            mx, mn = maxn, minn
            # if nums[i] > 0:
            #     maxn = max(mx * nums[i], nums[i])
            #     minn = min(mn * nums[i], nums[i])
            # else:
            #     maxn = max(mn * nums[i], nums[i])
            #     minn = min(mx * nums[i], nums[i])
            # ans = max(maxn, ans)

            # 或者不用判断num[i]的正负性，直接每次对比取出最大最小值
            maxn = max(mx * nums[i], mn * nums[i], nums[i])
            minn = min(mx * nums[i], mn * nums[i], nums[i])
            ans = max(maxn, ans)
        return ans
```

#### [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)*

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

**示例:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**提示：**

- `pop`、`top` 和 `getMin` 操作总是在 **非空栈** 上调用。

```python
# 方法1.使用辅助栈，时间复杂度O(1)，空间复杂度O(n)
class MinStack:
    # 使用辅助栈，辅助栈里存储最小值
    # 当有元素需要入栈的时候，主栈正常压入，辅助栈同时压入该元素和辅助栈栈顶元素中小的元素
    # 元素出栈时，同时推出主栈和辅助栈的栈顶元素
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.min_stack = [float("inf")]

    def push(self, x: int) -> None:
        self.stack.append(x)
        self.min_stack.append(min(x, self.min_stack[-1]))

    def pop(self) -> None:
        self.stack.pop()
        self.min_stack.pop()

    def top(self) -> int:
        if self.stack:
            return self.stack[-1]

    def getMin(self) -> int:
        # 因为主栈与辅助栈的从外界压入的元素树相同，所以当栈中的元素为空时，返回None
        if self.stack:
            return self.min_stack[-1]

# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()

```

```python
# 栈中保存差值。时间复杂度O(1), 空间复杂度O(1)
class MinStack:
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []
        self.min_value = -1

    def push(self, x: int) -> None:
        if not self.stack:
            self.stack.append(0)
            self.min_value = x
        else:
            diff = x-self.min_value
            self.stack.append(diff)
            self.min_value = self.min_value if diff > 0 else x

    def pop(self) -> None:
        if self.stack:
            diff = self.stack.pop()
            if diff < 0:
                top = self.min_value
                self.min_value = top - diff
            else:
                top = self.min_value + diff
            return top

    def top(self) -> int:
        return self.min_value if self.stack[-1] < 0 else self.stack[-1] + self.min_value

    def getMin(self) -> int:
        return self.min_value if self.stack else -1
```

#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)*

编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表**：**

![1](./imgs/160.相交链表1.png)

在节点 c1 开始相交。

**示例 1：**

![1](./imgs/160.相交链表2.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

![1](./imgs/160.相交链表3.png)

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

![1](./imgs/160.相交链表4.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```

**注意：**

- 如果两个链表没有交点，返回 `null`.
- 在返回结果后，两个链表仍须保持原有的结构。

- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(*n*) 时间复杂度，且仅用 O(*1*) 内存。

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
# 1.暴力法，时间复杂度O(mn), 空间O(1)
# 2. 哈希表法，建立其中一个链表的节点哈希表，使用另一个链表的节点查询是否存在于哈希表中
# 时间复杂度：O(m+n)，空间复杂度O(m)或O(n)
# 3.双指针法
# 主要思想：假设两个链表间的到交点前的节点差为d，为了使两个链表能够在相同步数下到达交点
# 可以定义两个指针，初始分别指向两个链表的头节点，当其中一个指针到达尾节点时，另其的的下一个节点为另一个链表的头节点
# 另一个指针则保持在原链表中进行移动。这样即可在相同步数的情况下消除距离d，使两个指针能够达到交汇点
# 时间复杂度：O(m+n), 空间复杂度O(1)
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return
        p1, p2 = headA, headB
        # while p1 or p2:
        #     if p1 == p2:
        #         return p1
        # 
        #     p1 = p1.next
        #     p2 = p2.next
        #     if not p1 and not p2:
        #         return
        #     if not p1:
        #         p1 = headB
        #     if not p2:
        #         p2 = headA
        
        # 简洁版
        while p1 != p2:
            p1 = p1.next if p1 else headB
            p2 = p2.next if p2 else headA
        return p1
```

#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)*

给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1:**

```
输入: [3,2,3]
输出: 3
```

**示例 2:**

```
输入: [2,2,1,1,1,2,2]
输出: 2
```

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        # 1.哈希表计数
        # 2.排序
        # 3. 摩尔投票法：从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，总能找到最多的那个
        res = nums[0]
        count = 1
        for i in range(1, len(nums)):
            if res == nums[i]:
                count += 1
            elif count == 0:
                res = nums[i]
                count = 1
            else:
                count -= 1
        return res
```

#### [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)*

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，**计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。**

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

```python
# 动态规划
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        n = len(nums)
        if n < 2:
            return nums[-1]
        # dp = [0] * (n + 1)
        # dp[0], dp[1] = 0, nums[0]  # 需要设一个值为0的头节点
        # for i in range(2, n + 1):
        #     # 对于当前位置，只有偷与不偷两种状态
        #     # 取决于截止至上一个房子偷盗的数额与截止至上上个房子与当前房子数额和
        #     # 如果大于，则抢劫；小于则不抢劫
        #     dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])
        # return dp[-1]

        # 空间优化
        # dp[i]只与dp[i-1和dp[i-2]有关
        pre = curr = 0
        for num in nums:
            pre, curr = curr, max(curr, pre + num)
        return curr
```

#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)**

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`

```python
# 深度优先搜索，时间空间复杂度均为O(MN)
# 扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。
# 在深度优先搜索的过程中，每个搜索到的 11 都会被重新标记为 0。
# 最终岛屿的数量就是行深度优先搜索的次数
class Solution:
    def _dfs(self, grid, i, j):
        # 将网格中该位置的元素置0，表示该点已遍历过
        grid[i][j] = 0
        m, n = len(grid), len(grid[0])
        directions = [(-1, 0), (0, -1), (1, 0), (0, 1)]
        for dx, dy in directions:
            x, y = i + dx, j + dy
            # 如果没有越界，且该点等于"1"，则继续进行搜索
            if 0 <= x < m and 0 <= y < n and grid[x][y] == "1":
                self._dfs(grid, x, y)

    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        m, n = len(grid), len(grid[0])
        nums = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == "1":
                    self._dfs(grid, i, j)
                    nums += 1
        return nums
```

```python
import collections
# 广度优先搜索，时间复杂度O(MN), O(min(M,N))
# 扫描整个二维网格。如果一个位置为 1，则将其加入队列，开始进行广度优先搜索。
# 在广度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。直到队列为空，搜索结束。
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        nr = len(grid)
        if nr == 0:
            return 0
        nc = len(grid[0])

        num_islands = 0
        for r in range(nr):
            for c in range(nc):
                if grid[r][c] == "1":
                    num_islands += 1
                    grid[r][c] = "0"
                    neighbors = collections.deque([(r, c)])
                    while neighbors:
                        row, col = neighbors.popleft()
                        for x, y in [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]:
                            if 0 <= x < nr and 0 <= y < nc and grid[x][y] == "1":
                                neighbors.append((x, y))
                                grid[x][y] = "0"

        return num_islands
```

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)*

反转一个单链表。

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**进阶:**
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

# 1. 递归实现,时间复杂度O()
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        # 递归到最后一个节点， 该结点就是反转后的头结点
        tail = self.reverseList(head.next)
        # 让当前结点的下一个结点的next 指针指向当前节点
        head.next.next = head
        # 容易忽略使头节点指向空，否则会出现循环
        head.next = None
        return tail
```

```python
# 2. 迭代实现
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head:
            return head

        pre = None
        curr = head
        while curr:
            tmp = curr.next
            curr.next = pre
            pre = curr
            curr = tmp
        return pre	
```

```python
# 双指针
# 定义指针 curr，初始化为 head .
# 每次都让 head 下一个结点的 next 指向 curr ，实现一次局部反转
# 局部反转完成之后，curr 和 head 的 next 指针同时 往前移动一个位置
# 循环上述过程，直至 curr 到达链表的最后一个结点
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head:
            return head
        curr = head
        while head.next:
            tmp = head.next.next
            head.next.next = curr
            curr = head.next
            head.next = tmp

        return curr
```

#### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)**@

你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]

给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

**示例 1:**

```
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
```

**示例 2:**

```
输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

**提示：**

1. 输入的先决条件是由 **边缘列表** 表示的图形，而不是 邻接矩阵 。详情请参见[图的表示法](http://blog.csdn.net/woaidapaopao/article/details/51732947)。
2. 你可以假定输入的先决条件中没有重复的边。
3. `1 <= numCourses <= 10^5`

```python
from typing import List
from collections import deque

# 广度优先算法
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        indegrees = [0 for _ in range(numCourses)]
        adjacency = [[] for _ in range(numCourses)]
        queue = deque()
        # Get the indegree and adjacency of every course.
        for cur, pre in prerequisites:
            indegrees[cur] += 1
            adjacency[pre].append(cur)
        # Get all the courses with the indegree of 0.
        for i in range(len(indegrees)):
            if not indegrees[i]: queue.append(i)
        # BFS TopSort.
        while queue:
            pre = queue.popleft()
            numCourses -= 1
            for cur in adjacency[pre]:
                indegrees[cur] -= 1
                if not indegrees[cur]: queue.append(cur)
        return not numCourses
```

```python
# 深度优先算法
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        def dfs(i, adjacency, flags):
            if flags[i] == -1: return True
            if flags[i] == 1: return False
            flags[i] = 1
            for j in adjacency[i]:
                if not dfs(j, adjacency, flags): return False
            flags[i] = -1
            return True

        adjacency = [[] for _ in range(numCourses)]
        flags = [0 for _ in range(numCourses)]
        for cur, pre in prerequisites:
            adjacency[pre].append(cur)
        for i in range(numCourses):
            if not dfs(i, adjacency, flags): return False
        return True
```

[参考解析](https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/)

#### [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)**@

实现一个 Trie (前缀树)，包含 `insert`, `search`, 和 `startsWith` 这三个操作。

**示例:**

```
Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
```

**说明:**

- 你可以假设所有的输入都是由小写字母 `a-z` 构成的。
- 保证所有输入均为非空字符串。

#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)**

在未排序的数组中找到第 **k** 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素

**示例 1:**

```
输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
```

**说明:**

你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。

```python
# 暴力法，先排序，后取值
# 时间复杂度O(NlogN) （主要消耗在排序的复杂度）， 空间复杂度O(1) （原地排序）
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        nums.sort()
        return nums[len(nums) - k]
```



```python
from typing import List
import heapq


# 使用堆排序实现
# 遍历数组建立一个结点数为k的最大堆，堆顶元素即为第k个最大的元素
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        heap = []
        n = len(nums)
        for i in range(n):
            
            if len(heap) < k:
                heapq.heappush(heap, nums[i])
            else:
                if nums[i] > heap[0]:
                    heapq.heapreplace(heap, nums[i])
                    
        return heap[0]
```

```python
# 快速排序中的partition思想
# 标记索引处之前的值都小于等于标记值，之后的都大于等于标记值
# 所以只需要当标记索引为目标索引时，目标索引处的索引即为第k大的索引
class Solution:
    def _partition(self, nums, left, right):
        # 由于没有进行完全的快速排序，此处不能使用随机法选取标记索引
        pivot = nums[left]
        i = left
        for j in range(left + 1, right + 1):
            # 小于标记值的，交换到前方
            if nums[j] < pivot:
                # 需要将指针先右移，防止覆盖标记值
                i += 1
                nums[i], nums[j] = nums[j], nums[i]

        nums[left], nums[i] = nums[i], nums[left]
        return i

    def findKthLargest(self, nums: List[int], k: int) -> int:
        n = len(nums)
        target = n - k
        left, right = 0, n - 1
        while True:
            idx = self._partition(nums, left, right)
            if idx == target:
                return nums[idx]
            elif idx < target:
                left = idx + 1
            else:
                right = idx - 1
```

#### [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)**

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

**示例 1：**

![示例1](./imgs/221.最大正方形1.jpg)

```
输入：matrix = [
["1","0","1","0","0"],
["1","0","1","1","1"],
["1","1","1","1","1"],
["1","0","0","1","0"]]
输出：4
```

**示例2**

![示例1](./imgs/221.最大正方形2.jpg)

```
输入：matrix = [["0","1"],["1","0"]]
输出：1
```

**示例 3：**

```
输入：matrix = [["0"]]
输出：0
```

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`

- `1 <= m, n <= 300`
- `matrix[i][j]` 为 `'0'` 或 `'1'`

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix:
            return 0
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * n for _ in range(m)]
        max_edge = 0

        for i in range(m):
            for j in range(n):
                if i == 0 or j == 0:
                    dp[i][j] = int(matrix[i][j])
                elif matrix[i][j] == '1':
                    # [i,j] 位置的正方形大小取决于左上角的可形成的最大正方形的最小值
                    # 即取三者中的最小值 + 1
                    # 如下例中，可形成的最大正方形面积为16而不是25
                    #           [["1", "1", "1", "1", "0"],
                    #           ["1", "1", "1", "1", "0"],
                    #           ["1", "1", "1", "1", "1"],
                    #           ["1", "1", "1", "1", "1"],
                    #           ["0", "0", "1", "1", "1"]]
                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1

                max_edge = max(dp[i][j], max_edge)

        return max_edge * max_edge
```

#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)*

翻转一棵二叉树。

**示例：**

输入：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

**备注:**
这个问题是受到 [Max Howell ](https://twitter.com/mxcl)的 [原问题](https://twitter.com/mxcl/status/608682016205344768) 启发的 ：

谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

# 递归实现，DFS
# 后序遍历
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        self.invertTree(root.left)
        self.invertTree(root.right)
        # 先序遍历或后序遍历都可以实现， 此处使用后序遍历实现
        root.left, root.right = root.right, root.left

        return root
```

```python
# 迭代实现，BFS
# 先序遍历实现
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return root
        queue = [root]
        while queue:
            node = queue.pop(0)
            node.left, node.right = node.right, node.left
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

        return root
```

#### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)*

请判断一个链表是否为回文链表。

**示例 1:**

```
输入: 1->2
输出: false
```

**示例 2:**

```
输入: 1->2->2->1
输出: true
```

**进阶：**
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？