

## Leetcode Hot 100题

#### 1. 两数之和*

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:

> 给定 nums = [2, 7, 11, 15], target = 9
>
> 因为 nums[0] + nums[1] = 2 + 7 = 9
>所以返回 [0, 1]

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        # res = []
        for i, n in enumerate(nums):
            dic[n] = i

        # for i, n in enumerate(nums):
        #     dif = target - n
        #     if dif in dic and dic[dif] != i:
        #         res.append(i)
        #         res.append(dic[dif])
        #         break
        # return res
        for i, n in enumerate(nums):
            dif = target - n
            if dif in dic and dic[dif] != i:
                return [i, dic[dif]]
```



#### 2. 两数相加**

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

> 示例：
>
> 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
> 输出：7 -> 0 -> 8
> 原因：342 + 465 = 807

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next


class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = p = ListNode()
        flag = 0
        while l1 or l2 or flag:
            s = (l1.val if l1 else 0) + (l2.val if l2 else 0) + flag
            p.next = ListNode(s % 10)
            p = p.next
            flag = s // 10
            
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None

        return head.next
```



#### 3. 无重复字符的最长子串**

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

> 示例 1:
>
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> 示例 2:
>
> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> 示例 3:
>
> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> 示例 4:
>
> 输入: s = ""
> 输出: 0

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        n = len(s)
        if n < 2: return n

        # 滑动窗口思想
        # 方法1： 标记字符的位置
        # dic = {}
        # left, right = 0, 0
        # maxlen = 0
        # while right < n:
        #     c = s[right]
        #
        #     if c in dic:
        #         left = max(dic[c], left)
        #     maxlen = max(maxlen, right - left + 1)
        #     dic[c] = right + 1
        #     right += 1
        #
        # return maxlen

        # 方法2：统计窗口内的字符数
        # 可用set替换dict
        left, right = 0, 0
        maxlen = 0
        dic = {}
        while right < n:
            if s[right] not in dic:
                dic[s[right]] = 1
                right += 1
                maxlen = max(maxlen, len(dic))
            else:
                del dic[s[left]]
                left += 1

        return maxlen
```

#### 4. [寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)***@

给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。

进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？

> 示例 1：
>
> 输入：nums1 = [1,3], nums2 = [2]
> 输出：2.00000
> 解释：合并数组 = [1,2,3] ，中位数 2
> 示例 2：
>
> 输入：nums1 = [1,2], nums2 = [3,4]
> 输出：2.50000
> 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
> 示例 3：
>
> 输入：nums1 = [0,0], nums2 = [0,0]
> 输出：0.00000
> 示例 4：
>
> 输入：nums1 = [], nums2 = [1]
> 输出：1.00000
> 示例 5：
>
> 输入：nums1 = [2], nums2 = []
> 输出：2.00000
>
>
> 提示：
>
> nums1.length == m
> nums2.length == n
> 0 <= m <= 1000
> 0 <= n <= 1000
> 1 <= m + n <= 2000
> -106 <= nums1[i], nums2[i] <= 106

[参考解析](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/)

```python

```

#### 5. [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)**

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

> **示例 1：**
>
> ```
> 输入: "babad"
> 输出: "bab"
> 注意: "aba" 也是一个有效答案。
> ```
>
> **示例 2：**
>
> ```
> 输入: "cbbd"
> 输出: "bb"
> ```

[参考解析](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/)

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        # 1. 暴力匹配:O(N^3), O(1)
        # n = len(s)
        # if n < 2:
        #     return s
        #
        # maxlen = 1
        # res = s[0]
        # for i in range(n - 1):
        #     for j in range(i + 1, n):
        #         if self.isPalindrome(s, i, j) and j - i + 1 > maxlen:
        #             maxlen = j - i + 1
        #             res = s[i: j + 1]
        #
        # return res

        # def isPalindrome(self, s, left, right):
        #     while left < right:
        #         if s[left] != s[right]:
        #             return False
        #         left += 1
        #         right -= 1
        #
        #     return True

        # 2.动态规划：O(N^2), O(N^2)
        # n = len(s)
        # if n < 2:
        #     return s
        # # dp[i][j]状态表示从索引i到j的子串是否为回文
        # dp = [[False] * n for _ in range(n)]
        # start, maxlen = 0, 1
        # for i in range(n):
        #     dp[i][i] = True
        #
        # 注意填表顺序
        # for j in range(1, n):
        #     for i in range(0, n):
        #         if s[i] == s[j]:
        #             if j - 1 - (i + 1) + 1 < 2:
        #                 dp[i][j] = True
        #             else:
        #                 dp[i][j] = dp[i + 1][j - 1]
        #         else:
        #             dp[i][j] = False
        #
        #         if dp[i][j]:
        #             cur_len = j - i + 1
        #             if cur_len > maxlen:
        #                 maxlen = cur_len
        #                 start = i
        #         return s[start:start + maxlen]

        # 3. 中心扩撒法
        size = len(s)
        if size < 2:
            return s

        # 至少是 1
        max_len = 1
        res = s[0]

        for i in range(size):
            palindrome_odd, odd_len = self.__center_spread(s, size, i, i)
            palindrome_even, even_len = self.__center_spread(s, size, i, i + 1)

            # 当前找到的最长回文子串
            cur_max_sub = palindrome_odd if odd_len >= even_len else palindrome_even
            if len(cur_max_sub) > max_len:
                max_len = len(cur_max_sub)
                res = cur_max_sub

        return res

    def __center_spread(self, s, size, left, right):
        """
        left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数
        right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数
        """
        i = left
        j = right

        while i >= 0 and j < size and s[i] == s[j]:
            i -= 1
            j += 1
        return s[i + 1:j], j - i - 1
```

#### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)***@

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

示例 1：

```
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

示例 2:

```
输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

示例 3：

```
输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```


示例 4：

```
输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```

示例 5：

```
输入：s = "mississippi" p = "mis*is*p*."
输出：false
```

#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)**

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器。

示例1：

![示例1图](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```


示例 2：

```
输入：height = [1,1]
输出：1
```

示例 3：

```
输入：height = [4,3,2,1,4]
输出：16
```

示例 4：

```
输入：height = [1,2,1]
输出：2
```


提示：

```
n = height.length
2 <= n <= 3 * 104
0 <= height[i] <= 3 * 104
```

```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # 1. 暴力法：超时
        # n = len(height)
        # res = 0
        # for i in range(n):
        #     for j in range(i + 1, n):
        #         t = (j - i) * min(height[i], height[j])
        #         res = max(res, t)
        #
        # return res

        # 2.双指针
        i, j = 0, len(height) - 1
        res = 0
        while i < j:
            t = (j - i) * min(height[i], height[j])
            res = max(res, t)
            if height[i] <= height[j]:
                i += 1
            else:
                j -= 1
        return res
```

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)**

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例：

```
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

```python
from typing import List


class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        # 1. 暴力算法，时间复杂度O(n^3)
        # 2. 双指针法，O(n^2)
        n = len(nums)
        if n < 3:
            return []
        # 先对nums排序
        nums.sort()
        res = []
        # 设置三指针遍历求和
        # 第一个指针
        for i in range(n):
            # 因为nums是排序后的序列，如果nums[i] > 0，则表示后面的任意序列和都不可能等于0
            # 直接返回
            if nums[i] > 0:
                return res
            # 对于重复的元素，直接跳过，避免出现重复解
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            # 剩余的两个指针
            left, right = i + 1, n - 1
            while left < right:
                t = nums[i] + nums[left] + nums[right]
                if t == 0:
                    res.append([nums[i], nums[left], nums[right]])
                    # 去除重复解
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                # 当t < 0,表示left指针所对应的元素值太小，需要往右移动
                elif t < 0:
                    left += 1
                # 不然，right指针左移
                else:
                    right -= 1

        return res
```

#### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)**

给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```

**说明：**

给定的 *n* 保证是有效的。

**进阶：**

你能尝试使用一趟扫描实现吗？

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

# 方法1：直接遍历删除，时间O(L), 空间O(1), 需要两次遍历
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        def getLength(head: ListNode) -> int:
            length = 0
            while head:
                length += 1
                head = head.next
            return length
        
        dummy = ListNode(0, head)
        # 先计算链表长度
        length = getLength(head)
        cur = dummy
        for i in range(1, length - n + 1):
            cur = cur.next
        # 删除倒数第n个节点
        cur.next = cur.next.next
        return dummy.next

# 方法2：使用栈删除
# 方法3：双指针一次遍历，时间O(L),O(1)
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        p1 = head
        dummy = ListNode(0, head)
        p2 = dummy
        # 第一个指针先走n步
        for i in range(n):
            p1 = p1.next
        # 两指针同时移动
        while p1.next:
            p1 = p1.next
            p2 = p2.next
		# 节点删除
        p2.next = p2.next.next
        return dummy.next

```

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)*


给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**

```
输入: "()"
输出: true
```

**示例 2:**

```
输入: "()[]{}"
输出: true
```

**示例 3:**

```
输入: "(]"
输出: false
```

**示例 4:**

```
输入: "([)]"
输出: false
```

**示例 5:**

```
输入: "{[]}"
输出: true
```

```python
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        for c in s:
            # 左括号，压入栈
            if c == '(' or c == "[" or c == "{":
                stack.append(c)
            # 右括号，判断括号是否对应
            elif not stack or self._getRightParent(c) != stack.pop():
                return False
		# 当输入的字符串中或剩余的字符串中只包含单括号时，栈中的元素还会有剩余
        # 所以最后还需要判断栈中元素是否为空
        return not stack
        #     elif c == ")" and (not stack or stack.pop() != "(") :
        #         return False
        #     elif c == "]" and (not stack or stack.pop() != "["):
        #         return False
        #     elif c == "}" and (not stack or stack.pop() != "{"):
        #         return False
        #
        # return True if not stack else False

    def _getRightParent(self, ch):
        if ch == ")": return "("
        if ch == "]": return "["
        if ch == "}": return "{"

        
# S = "([)]"这种情况是属于括号不匹配的情况，return False
# S = "()[]{()}"
S = "]"
print(Solution().isValid(S))

```

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)*

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
# 方法1。迭代法。时间复杂度为O(L1+L2),空间复杂度O(1)
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1: return l2
        if not l2: return l1

        pHead = ListNode()
        p = pHead
        while l1 and l2:
            if l1.val <= l2.val:
                p.next = l1
                l1 = l1.next
            else:
                p.next = l2
                l2 = l2.next
            p = p.next
        # 将l1或l2链表中剩余的元素加入链表
        p.next = l1 if l1 else l2

        return pHead.next
    
# ---------------------------------------------
# 方法2.递归。时间复杂度O(L1+L2),空间复杂度O(L1+L2)
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1: return l2
        if not l2: return l1

        if l1.val <= l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

```python
# 验证
L1, L2 = 3, 3
p1, p2 = ListNode(), ListNode()
pt1, pt2 = p1, p2
print("第一个链表")
for i in range(L1):
    x = int(input())
    pt1.next = ListNode(x)
    pt1 = pt1.next

print("第二个链表")
for i in range(L2):
    x = int(input())
    pt2.next = ListNode(x)
    pt2 = pt2.next

print("输出结果")
res = Solution().mergeTwoLists(p1.next, p2.next)
while res:
    print(res.val)
    res = res.next
```

#### [23.合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)***@

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

#### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)**

实现获取 **下一个排列** 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        if n <= 1:
            return
        # 从后向前遍历
        # 定义三个指针i，j，k
        i, j, k = n - 2, n - 1, n - 1
        # 1.找到第一个相邻升序的元素（i，j），满足A[i] < A[j]；此时从j到结尾的序列必定为降序的序列
        while i >= 0 and nums[i] >= nums[j]:
            i -= 1
            j -= 1
        # 判断是否为最后一个排列
        if i >= 0:
            # 2.从j到结尾的序列中查找第一个比A[i]大的元素A[k]
            while nums[i] > nums[k]:
                k -= 1
            # 3.交换A[i]和A[k]的值，交换后的从j到结尾的序列此时也必定为降序排列
            nums[i], nums[k] = nums[k], nums[i]
        # 4.对j到结尾序列进行逆置，使其升序排序
        i, j = j, n - 1
        while i < j:
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
            j -= 1
        # 5.如果在步骤1中找不到符合的相邻元素，则说明原始序列为降序序列，则直接跳到步骤4
```

[参考解析](https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-suan-fa-xiang-jie-si-lu-tui-dao-/)

#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)***@

给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。

**示例 1:**

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

**示例 2:**

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```



#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)**

给你一个整数数组 nums ，和一个整数 target 。

该整数数组原本是按升序排列，但输入时在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。

请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

提示：

- 1 <= nums.length <= 5000
- -10^4 <= nums[i] <= 10^4
- nums 中的每个值都 独一无二
- nums 肯定会在某个点上旋转
- -10^4 <= target <= 10^4

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if not nums: return -1
        # 1.二分法查找
        n = len(nums)
        left, right = 0, n - 1
        while left <= right:
            mid = (left + right) // 2
            # 找到目标值，返回对应的索引
            if target == nums[mid]:
                return mid
            if nums[0] <= nums[mid]:
                # 如果处于区间[0, mid]区间内，则右指针移至中间指针的位置
                # 否则，左指针移动
                if nums[0] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[n - 1]:
                    left = mid + 1
                else:
                    right = mid - 1

        return -1
```



#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)**

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

**进阶：**

- 你可以设计并实现时间复杂度为 `O(log n)` 的算法解决此问题吗？

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

```python
# 二分法 & 递归
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums:
            return [-1, -1]

        return self.search(nums, 0, len(nums) - 1, target)

    def search(self, nums, left, right, target):
        if left > right:
            return -1, -1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                right = mid - 1
            else:
                if nums[left] != target:
                    left = self.search(nums, left + 1, mid, target)[0]
                if nums[right] != target:
                    right = self.search(nums, mid, right - 1, target)[1]
                return [left, right]

        return [-1, -1]
```



#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)**

​	给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

**说明：**

- 所有数字（包括 `target`）都是正整数。
- 解集不能包含重复的组合。

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```

**示例 2：**

```
输入：candidates = [2,3,5], target = 8,
所求解集为：
[
    [2,2,2,2],
      [2,3,3],
      [3,5]
]
```

```python
from typing import List


class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        # 1.回溯法
        # ans = []
        # n = len(candidates)
        #
        # def backtrack(i, val, record):
        #     # 如果差小于0，说明当前元素candidates[i]的值大了
        #     if val < 0:
        #         return
        #     # 等于0，说明方案可行
        #     if val == 0:
        #         ans.append(record[:])
        #         return
        #     for j in range(i, n):
        #         record.append(candidates[j])  # 添加
        #         backtrack(j, val - candidates[j], record)
        #         record.pop()  # 回溯
        #
        # backtrack(0, target, [])
        # return ans

        # 2. 回溯法，剪枝
        # 对candidates进行排序，当差值val<0时，则表示当前位置i之后的元素都不会满足要求
        # 因此跳过进一步的回溯
        # ans = []
        # n = len(candidates)
        # # 排序
        # candidates.sort()
        #
        # def backtrack(i, val, record):
        #     # 如果差小于0，说明当前元素candidates[i]的值大了
        #     if val < 0:
        #         return
        #     # 等于0，说明方案可行
        #     if val == 0:
        #         ans.append(record[:])
        #         return
        #     for j in range(i, n):
        #         if val - candidates[j] < 0:
        #             break
        #         record.append(candidates[j])  # 添加
        #         backtrack(j, val - candidates[j], record)
        #         record.pop()  # 回溯
        #
        # backtrack(0, target, [])
        # return ans

        # 方法1另一种写法,官方提供的不剪枝的朴素回溯法
        # 时间复杂度：O（S），S是所有可行解组成的长度之和，空间复杂度O（target）
        ans = []
        n = len(candidates)

        def backtrack(i, val, record):
            if i == n:
                return
            if val == 0:
                ans.append(record[:])
                return

            # 选择当前数
            if val - candidates[i] >= 0:
                record.append(candidates[i])
                backtrack(i, val - candidates[i], record)
                record.pop()

            # 直接跳过，通过索引后移实现for功能
            backtrack(i + 1, val, record)
        backtrack(0, target, [])
        return ans


# Candidates = [2,3,6,7]
# Target = 7
Candidates = [2, 3, 5]
Target = 8
print(Solution().combinationSum(Candidates, Target))

```



#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)***@

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![42示例图](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```



#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)**

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

**示例:**

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

```python
from typing import List


class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        # 方法1：添加一个标记数组
        # 标记数组的方法还可以具有有序性的特点
        # res = []
        # n = len(nums)
        # used = [False] * n
        #
        # def backtrack(record):
        #     if len(record) == n:
        #         res.append(record[:])
        #         return
        #     for i in range(n):
        #         if not used[i]:
        #             used[i] = True
        #             record.append(nums[i])
        #             backtrack(record)
        #             used[i] = False
        #             record.pop()
        #
        # backtrack([])
        # return res

        # 方法2： 将数组分成两个部分，前半部分是已排列过的数据，后半部分为没有排列过的
        # 如：nums = [1, 2, 3,,4],分为两部分： [1, 2 | 3, 4], 1和2为已经使用过的数据
        res = []
        n = len(nums)

        def backtrack(first):
            if first == n:
                res.append(nums[:])
                return
            for i in range(first, n):
                # 注意：i的初始位置需要从first开始，而不是first + 1
                # 动态维护数组
                # 交换双方位置
                nums[first], nums[i] = nums[i], nums[first]
                backtrack(first + 1)
                nums[first], nums[i] = nums[i], nums[first]

        backtrack(0)
        return res


Nums = [1, 2, 3]
print(Solution().permute(Nums))

```

#### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)**

给定一个 *n* × *n* 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

**说明：**

你必须在**[原地](https://baike.baidu.com/item/原地算法)**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。

**示例 1:**

```python
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**示例 2:**

```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        if not matrix:
            return
        n = len(matrix)
        # 方法1：先转置矩阵，再每行翻转
        # 时间复杂度O(N^2)
        for i in range(n):
            for j in range(i, n):
                matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i]

        for i in range(n):
            for j in range(n//2):
                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]
```



#### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)**

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

**示例:**

```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

**说明：**

- 所有输入均为小写字母。
- 不考虑答案输出的顺序。

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        if not strs:
            return []

        # 方法1. 字符串排序,时间复杂度O(nklog(k))，k是字符串的最大长度， 空间复杂度O（nk）
        # dic = {}
        # for s in strs:
        #     key = "".join(sorted(s))
        #     if key not in dic:
        #         dic[key] = [s]
        #     else:
        #         dic[key].append(s)
        # return list(dic.values())

        # 方法2：计数,时间复杂度O（n（k+26）），生成哈希表的键需要O（26）的时间复杂度
        dic = {}
        for s in strs:
            # 两个字符串中的相同字母出现的次数一定是相同的
            # 故可以将每个字母出现的次数使用字符串表示
            count = [0] * 26
            for c in s:
                count[ord(c) - ord("a")] += 1

            # 数组需要转换成tuple才能哈希
            key = tuple(count)
            if key not in dic:
                dic[key] = [s]
            else:
                dic[key].append(s)

        return list(dic.values())
```



#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)*

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶:**

如果你已经实现复杂度为 O(*n*) 的解法，尝试使用更为精妙的分治法求解。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        # 1.贪心算法，时间复杂度O(n),空间O(1)
        # 主要思想：判断当前位置之前的序列元素和是否大于0.
        # 如果大于0，则与当前元素相加，记作当前和curr_sum；如果小于0，则curr_sum直接取当前元素值
        # 对比curr_sum与最大和max_sum，取最大值赋与max_sum
        # curr_sum = max_sum = nums[0]
        # for i, num in enumerate(nums):
        #     if i == 0:
        #         continue
        #     curr_sum = max(curr_sum + num, num)
        #     max_sum = max(max_sum, curr_sum)
        #
        # return max_sum

        # 方法2：动态规划,复杂度同
        # 主要思想：判断原地修改后的nums中当前位置的前一个位置的值是否大于0
        # 如果前一个位置值大于0，则当前位置的新值等于两者之和；否则，当前值保持不变.最后，取数组中的最大值返回
        max_sum = nums[0]
        for i in range(1, len(nums)):
            if nums[i - 1] > 0:
                nums[i] += nums[i - 1]
            max_sum = max(max_sum, nums[i])

        return max_sum
```



#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)**

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

**示例 1:**

```
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```

**示例 2:**

```
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        # 贪心思想，尽可能到达最远的位置
        # 主要思想：如果能到达某个位置，那一定能到达它前面的所有位置
        # 方法：初始化最远位置为 0，然后遍历数组，如果当前位置能到达，并且当前位置+跳数>最远位置，就更新最远位置。最后比较最远位置和数组长度。
        # 初始化当前能够到达的最远位置
        # max_i = 0
        # for i in range(len(nums)):
        #     # 如果当前位置可达，且当前位置加上当前位置能够跳跃的最大跳数大于最远跳数
        #     # 则更新最远跳数max_i
        #     if max_i >= i:
        #         max_i = max(max_i, i + nums[i])
        #
        # # 如果最远跳数大于数组长度，则表示能够到达最后的位置
        # return max_i >= len(nums)
        
        # 小简化，提升速度
        max_i = 0
        for i in range(len(nums)):
            # 如果位置i大于能够到达的最远跳数，则说明当前位置之前的最大跳数不能够达到当前位置，说明后面位置也永远到达不了，直接返回
            if i > max_i: return False
            max_i = max(max_i, i + nums[i])
        return True
```



#### [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)**

给出一个区间的集合，请合并所有重叠的区间。

**示例 1:**

```python
输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2:**

```
输入: intervals = [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        # 方法：排序 & 合并。时间和空间复杂度取决于排序的复杂度，即O(NlogN)，空间O(logN)，
        # 对每个区间的左端点进行排序
        intervals.sort(key=lambda x: x[0])

        merged = []
        for int in intervals:
            # 如果列表为空，或当前区间与上一个区间不重合，则直接添加
            if not merged or merged[-1][1] < int[0]:
                merged.append(int)
            else:
                # 否则，可以对区间进行合并
                merged[-1][1] = max(merged[-1][1], int[1])
        return merged
```



#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)**

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![不同路径](./62.不同路径.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 方法1：深度搜索DFS，运行超时
        # visited = [[False] * n for _ in range(m)]
        # global res
        # res = 0
        #
        # def dfs(i, j):
        #     if i == m - 1 and j == n - 1:
        #         global res
        #         res += 1
        #         return
        #
        #     if i < m and j < n:
        #         if not visited[i][j]:
        #             visited[i][j] = True
        #             dfs(i + 1, j)
        #             dfs(i, j + 1)
        #             visited[i][j] = False
        #
        # dfs(0, 0)
        # return res

        # 方法2：动态规划，时间复杂度O(MN),空间O(MN)
        # 主要思想：能够到达当前位置的路径和等于能够到达上一行同列位置的路径数 + 同一行前一列的路径数之和
        # dp = [[0] * n for _ in range(m)]
        # for i in range(m):
        #     for j in range(n):
        #         # 由于只能向下向右移动，所以第一行和第一列的位置能到达的路径数为1
        #         if i == 0 or j == 0:
        #             dp[i][j] = 1
        #         else:
        #             dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        #
        # return dp[-1][-1]

        # 方法3：动态规划，空间优化，时间复杂度O（MN）， 空间复杂度O（2N）= O(N)
        # 优化依据：dp[i][j]每次只与dp[i-1][j] 和 dp[i][j-1]有关
        # pre: 前一行，curr：当前行
        # pre, curr = [1] * n, [1] * n
        # for i in range(1, m):
        #     for j in range(1, n):
        #         curr[j] = pre[j] + curr[j - 1]
        #     pre = curr
        # return curr[-1]

        # 方法4：动态优化，空间优化,O(N)
        # 优化依据：?
        curr = [1] * n
        for i in range(1,m):
            for j in range(1,n):
                curr[j] += curr[j - 1]
        return curr[-1]
```

#### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)**

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

![不同路径](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/62.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.png)

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

**示例 1：**

![不同路径2](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/63.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842.jpg)

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        # 1.自写
        # if obstacleGrid[0][0] == 1:
        #     return 0
        # m, n = len(obstacleGrid), len(obstacleGrid[0])
        # dp = [[0] * n for _ in range(m)]
        # for i in range(m):
        #     for j in range(n):
        #         if obstacleGrid[i][j] == 1:
        #             dp[i][j] = 0
        #         else:
        #             if i == 0 and j == 0:
        #                 dp[0][0] = 1
        #             elif i == 0 and j > 0:
        #                 dp[i][j] += dp[i][j - 1]
        #             elif j == 0 and i > 0:
        #                 dp[i][j] += dp[i - 1][j]
        #             else:
        #                 dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        #         # print(i, j, dp)
        # return dp[-1][-1]

        #题解 2. 滚动数组优化
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        f = [0] * n
        f[0] = 0 if obstacleGrid[0][0] == 1 else 1
        for i in range(m):
            for j in range(n):
                if obstacleGrid[i][j] == 1:
                    f[j] = 0
                elif j >= 1 and obstacleGrid[i][j - 1] == 0:
                    f[j] += f[j - 1]

        return f[-1]
```



#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)**

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例 1：**

![最小路径和](https://cdn.jsdelivr.net/gh/voyagerw/imgbed/imgs/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**示例 2：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

提示：

- m == grid.length
- n == grid[i].length
- 1 <= m, n <= 200
- 0 <= grid[i][j] <= 100

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        # 方法1. 动态规划
        # 当前位置最小值只与同行前一列或同列前一行的元素的最小值相关
        m, n = len(grid), len(grid[0])
        dp = [[float('inf')] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                if i == 0 and j == 0:
                    dp[i][j] = grid[i][j]
                else:
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]

        return int(dp[-1][-1])

        # 优化：如题62相同，空间复杂度可以优化，例如每次只存储上一行的 \textit{dp}dp 值，则可以将空间复杂度优化到 O(n)O(n)。
```



#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)*

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        # 方法：动态规划
        # if n < 3: return n
        # dp = [0] * (n + 1)
        # dp[0], dp[1] = 1, 1
        # for i in range(2, n + 1):
        #     dp[i] = dp[i - 1] + dp[i - 2]
        # return dp[-1]

        # 空间优化
        if n < 3: return n
        a, b = 1, 2
        for i in range(3, n + 1):
            c = a + b
            a, b = b, c
        return c
```

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)***@

给你两个单词 `word1` 和 `word2`，请你计算出将 `word1` 转换成 `word2` 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```python
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

**提示：**

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        # 参考LCS的思路
        m, n = len(word1), len(word2)
        # 状态dp[i][j]表示最少的操作数使得word1的前i个字符和word2的前j个字符
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1): dp[i][0] = i
        for j in range(n + 1): dp[0][j] = j

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 当元素相同时，不进行操作
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                # 否则，对比
                else:
                    dp[i][j] = min(dp[i - 1][j - 1] + 1, min(dp[i][j - 1] + 1, dp[i - 1][j] + 1))

        return dp[m][n]
```

#### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**进阶：**

- 你可以不使用代码库中的排序函数来解决这道题吗？
- 你能想出一个仅使用常数空间的一趟扫描算法吗？

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

**示例 3：**

```
输入：nums = [0]
输出：[0]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

```python
# 方法1~方法3参考自官方题解
# 方法1：单指针
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        n = len(nums)
        ptr = 0
        for i in range(n):
            if nums[i] == 0:
                nums[i], nums[ptr] = nums[ptr], nums[i]
                ptr += 1
        for i in range(ptr, n):
            if nums[i] == 1:
                nums[i], nums[ptr] = nums[ptr], nums[i]
                ptr += 1
# 方法2：双指针
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        n = len(nums)
        p0 = p1 = 0
        for i in range(n):
            if nums[i] == 1:
                nums[i], nums[p1] = nums[p1], nums[i]
                p1 += 1
            elif nums[i] == 0:
                nums[i], nums[p0] = nums[p0], nums[i]
                if p0 < p1:
                    nums[i], nums[p1] = nums[p1], nums[i]
                p0 += 1
                p1 += 1

# 方法3：双指针
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        n = len(nums)
        p0, p2 = 0, n - 1
        i = 0
        while i <= p2:
            while i <= p2 and nums[i] == 2:
                nums[i], nums[p2] = nums[p2], nums[i]
                p2 -= 1
            if nums[i] == 0:
                nums[i], nums[p0] = nums[p0], nums[i]
                p0 += 1
            i += 1
            
# 方法4：partition思想
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """

        def swqp(nums, idx1, idx2):
            nums[idx1], nums[idx2] = nums[idx2], nums[idx1]

        # 方法1. 使用快速排序中的partition思想，即
        # all in [0, zero) = 0
        # all in [zero, i) = 1
        # all in [two, len - 1] = 2
        # 时间复杂度：O(N)
        if len(nums) < 2: return
        i, zero, two = 0, 0, len(nums)
        while i < two:
            if nums[i] == 0:
                # 当值等于0时，交换i和zero的对应元素的值，然后i和zero都向右移
                swqp(nums, i, zero)
                i += 1
                zero += 1
            elif nums[i] == 1:
                # 当值等于1时，i指针右移，其余指针保持
                i += 1
            else:
                # 当值等于2时，因为two初始设置为nums的长度，直接处理会越界，需要先左移
                two -= 1
                swqp(nums, i, two)
```

以上方法时间复杂度均为O(N)，空间O(1)

[方法1~方法3参考](https://leetcode-cn.com/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode-solution/)

[方法4参考](https://leetcode-cn.com/problems/sort-colors/solution/kuai-su-pai-xu-partition-guo-cheng-she-ji-xun-huan/)

#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)***@

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

**注意：**如果 s 中存在这样的子串，我们保证它是唯一的答案。

**示例 1：**

```
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```

**示例 2：**

```
输入：s = "a", t = "a"
输出："a"
```

#### [78. 子集](https://leetcode-cn.com/problems/subsets/)**

给定一组**不含重复元素**的整数数组 *nums*，返回该数组所有可能的子集（幂集）。

**说明：**解集不能包含重复的子集。

**示例:**

```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        if not nums: return [nums]
        # 方法1：回溯
        # 时间复杂度O(n*2^n).一共2^n个状态，每个状态需要O(n)的时间构建子集
        # 空间复杂度O(n). 临时数组 tt 的空间代价是 O(n)O(n)，递归时栈空间的代价为 O(n)O(n)。
        res = []

        def dfs(curr, t):
            # 记录答案
            if curr == len(nums):
                res.append(t[:])
                return
            # 考虑选择当前位置
            t.append(nums[curr])
            dfs(curr + 1, t)
            t.pop()
            # 不考虑选择当前位置
            dfs(curr + 1, t)

        dfs(0, [])
        return res
```

#### [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)**

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例:**

```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
```

**提示：**

- `board` 和 `word` 中只包含大写和小写英文字母。
- `1 <= board.length <= 200`

- `1 <= board[i].length <= 200`
- `1 <= word.length <= 10^3`