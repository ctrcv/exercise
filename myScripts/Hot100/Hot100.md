## Leetcode Hot 100题

#### 1. 两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。



> 示例:
>
> 给定 nums = [2, 7, 11, 15], target = 9
>
> 因为 nums[0] + nums[1] = 2 + 7 = 9
> 所以返回 [0, 1]

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dic = {}
        # res = []
        for i, n in enumerate(nums):
            dic[n] = i

        # for i, n in enumerate(nums):
        #     dif = target - n
        #     if dif in dic and dic[dif] != i:
        #         res.append(i)
        #         res.append(dic[dif])
        #         break
        # return res
        for i, n in enumerate(nums):
            dif = target - n
            if dif in dic and dic[dif] != i:
                return [i, dic[dif]]
```



#### 2. 两数相加

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

> 示例：
>
> 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
> 输出：7 -> 0 -> 8
> 原因：342 + 465 = 807

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next


class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = p = ListNode()
        flag = 0
        while l1 or l2 or flag:
            s = (l1.val if l1 else 0) + (l2.val if l2 else 0) + flag
            p.next = ListNode(s % 10)
            p = p.next
            flag = s // 10
            
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None

        return head.next
```



#### 3. 无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

> 示例 1:
>
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> 示例 2:
>
> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> 示例 3:
>
> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> 示例 4:
>
> 输入: s = ""
> 输出: 0

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        n = len(s)
        if n < 2: return n

        # 滑动窗口思想
        # 方法1： 标记字符的位置
        # dic = {}
        # left, right = 0, 0
        # maxlen = 0
        # while right < n:
        #     c = s[right]
        #
        #     if c in dic:
        #         left = max(dic[c], left)
        #     maxlen = max(maxlen, right - left + 1)
        #     dic[c] = right + 1
        #     right += 1
        #
        # return maxlen

        # 方法2：统计窗口内的字符数
        left, right = 0, 0
        maxlen = 0
        dic = {}
        while right < n:
            if s[right] not in dic:
                dic[s[right]] = 1
                right += 1
                maxlen = max(maxlen, len(dic))
            else:
                del dic[s[left]]
                left += 1

        return maxlen
```

